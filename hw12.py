# ф-ию Фибоначчи можно написать, используя матрицы: ([[0 1] [1 1]]) * ([Fn-1] [Fn]) = ([Fn] [Fn+1]). Любое число последовательности (k-ое) можно получить из 0-ого и первого чисел последовательности,
# умножая матрицу ([[0 1] [1 1]]) k раз на ([F0] [F1]). То есть ([Fk] [Fk+1]) = ([[0 1] [1 1]])** k * ([F0] [F1]).
# пример вычисление 2-ого числа: ([[0 1] [1 1]])**2* ([1] [1]) = ([[0 1] [1 1]])* ([[0 1] [1 1]])* ([1] [1]) = ([1 1] [1 2])*([1] [1]) = ([2] [3])=> 2-ое число в посл-ти - 2, 3-ее - 3
# возведение матрицы в степень: А**10 = А**8 * А**2 = ((А**2)**2)**2 * А**2

def multiply_matrix(matrix_a,matrix_b):
    return [[
            matrix_a[0][0] * matrix_b[0][0] + matrix_a[0][1] * matrix_b[1][0],
            matrix_a[0][0] * matrix_b[0][1] + matrix_a[0][1] * matrix_b[1][1]
            ], [
            matrix_a[1][0] * matrix_b[0][0] + matrix_a[1][1] * matrix_b[1][0],
            matrix_a[1][0] * matrix_b[0][1] + matrix_a[1][1] * matrix_b[1][1]
        ]]


def fib(n):
    matrix_A = [[0, 1], [1, 1]]
    matrix_B = [[0, 1], [1, 1]]
    while n:
        if n%2!=0: #если число нечетное умножаем матрицу на изначальную и уменьшаем n на 1
            matrix_B= multiply_matrix(matrix_B, matrix_A)
            n=n-1
        else: #если число четное умножаем матрицу на саму себя и делим n пополам
            matrix_A=multiply_matrix(matrix_A, matrix_A)
            n = n // 2
    return matrix_B[0][0]

# print(fib(5432))










